#ifndef _GAZEBO_SHIP_H_
#define _GAZEBO_SHIP_H_

//-----------------------------------------------------------------------------
#include "common.h"
#include "constants.h"
#include "aabb.h"
#include "command.h"
#include "state.h"
#include "utilities.h"
#include "space.h"
#include "controller.h"
#include "sensor.h"
#include "planner.h"

//-----------------------------------------------------------------------------
// Simulator
#include <gazebo/gazebo.hh>
#include <gazebo/common/Plugin.hh>
#include <gazebo/common/common.hh>
#include <gazebo/common/Events.hh>
#include <gazebo/physics/physics.hh>
/*
//-----------------------------------------------------------------------------
// PDF
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_multifit_nlin.h>
*/
//-----------------------------------------------------------------------------
// Math
#include <Ravelin/Pose3d.h>
#include <Ravelin/SVelocityd.h>
#include <Ravelin/SAcceld.h>
#include <Ravelin/SForced.h>
#include <Ravelin/SpatialRBInertiad.h>
#include <Ravelin/MatrixNd.h>

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/// Class encapsulating the ship itself.  A Gazebo plugin
class ship_c : public gazebo::ModelPlugin {
public:

  //---------------------------------------------------------------------------
  // Open Parameters
  //---------------------------------------------------------------------------
  double FLEE_DISTANCE;
  double CAPTURE_DISTANCE;
  double PREY_MAX_FORCE;
  double PREY_MAX_TORQUE;
  double PREY_PREDATOR_FORCE_WEIGHT;
  double PREY_COMBINED_FORCE_WEIGHT;
  double PREY_BOUNDARY_FORCE_WEIGHT;

  // the time step used by the planner
  double PLANNER_STEP_SIZE;
  double PLANNER_MAX_PLANNING_TIME;
  double PLANNER_MAX_DERIVATIVE;
  double PLANNER_MAX_FORCE;
  double PLANNER_GOAL_BIAS;

  double FEEDBACK_GAIN_PROPORTIONAL_POSITION;
  double FEEDBACK_GAIN_DERIVATIVE_POSITION;
  double FEEDBACK_GAIN_PROPORTIONAL_ROTATION;
  double FEEDBACK_GAIN_DERIVATIVE_ROTATION;

  double DRAG;
  double REPULSIVE_FORCE_ALPHA;

  // Variables for the Random Walk planning
  double GAUSSIAN_MEAN;
  double GAUSSIAN_VARIANCE;
  double GAUSSIAN_STDDEV;

  //---------------------------------------------------------------------------
  // Members
  //---------------------------------------------------------------------------
  // the reference so that this ship is inserted into gazebo's callback system
  gazebo::event::ConnectionPtr updateConnection;
  // the gazebo reference to the world in which the ship is located
  gazebo::physics::WorldPtr world;
  // the gazebo reference to the ship's model 
  gazebo::physics::ModelPtr model;
  // the gazebo reference to the ship's link
  gazebo::physics::LinkPtr body;

  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  // the set of feedforward commands generated by the planner
  ship_command_list_t commands;

  // the current command being executed by the ship
  ship_command_c command;

  // the time left the current command is to be executed
  double command_duration;

  pp_state_c state;

  // information about the adversary/opponent 
  ship_p self;
  ship_p adversary;

  // the set of possible game types
  enum game_type_e {
    UNDEFINED,
    SOLO,
    PURSUIT
  };

  // the type of game that has started
  game_type_e GAME_TYPE;

  // the set of possible player types
  enum player_type_e {
    NONE,
    PREY,
    PREDATOR
  };

  // my player type
  player_type_e PLAYER_TYPE;
  // my adversary's player type
  player_type_e ADVERSARY_TYPE;

  // the inertial mass matrix of the ship
  Ravelin::SpatialRBInertiad inertial;

  ship_sensor_c pred_sensor, prey_sensor;

  // the current time of the simulation
  double TIME;

  // the size of the last time step the simulation took
  double DT;

  // the time at which the simulation legitimately started
  double TIME_START;

  // the time of the last update
  double TIME_LAST;

  bool first_update;

  // whether the ship should stop interacting with the world
  bool stopped;

  // the ship's bounding box in the ship's frame of reference
  aabb_c ship_frame_bb;

  // the world's spatial boundary
  aabb_c spatial_bound;

  // the world's spatial information
  space_c space;

  // the list of all obstacles in the world
  aabb_list_t obstacles;

  // whether or not a capture event has occurred
  bool capture;

  ship_controller_c controller;

protected:
  // the type of planner this ship uses
public:

  planner_c planner;

  // audit file names
  std::string audit_file_planned_commands;
  std::string audit_file_planned_states;
  std::string audit_file_actual_commands;
  std::string audit_file_actual_states;
  std::string audit_file_fb_commands;
  std::string audit_file_ff_commands;
  std::string audit_file_interp_states;
  std::string audit_file_fb_error;
  std::string audit_file_control_values;


public:
  //---------------------------------------------------------------------------
  // Constructors
  //---------------------------------------------------------------------------
  ship_c( void );
  ship_c( ship_c* owner, const player_type_e& player_type );
    
  //---------------------------------------------------------------------------
  // Destructor
  //---------------------------------------------------------------------------
  virtual ~ship_c( void );

protected:
  //---------------------------------------------------------------------------
  // Gazebo ModelPlugin Interface
  //---------------------------------------------------------------------------
  // Gazebo callback.  Called when the simulation is starting up
  virtual void Load( gazebo::physics::ModelPtr _model, sdf::ElementPtr _sdf );

  // Gazebo callback.  Called whenever the simulation advances a timestep
  virtual void Update( );

  // Gazebo callback.  Called whenever the simulation is reset
  //virtual void Reset( );

  //---------------------------------------------------------------------------
  // Robot Interface
  //---------------------------------------------------------------------------
  // general initialization not directly related to gazebo (called by gazebo Init)
  virtual void init( void );

  // handles any sensing for a given time step
  virtual void sense( pp_state_c& q );

  // handles any planning for a given time step
  virtual bool plan( pp_state_c& q, ship_command_c& u );

  // handles any acting behavior for a given time step
  virtual void act( pp_state_c& q, ship_command_c& u );

  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  bool read_model( gazebo::physics::ModelPtr _model );

  bool read_adversary( void );
  
  bool read_world( void );
  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
/*  
  // plan for each role
  bool plan_for_prey( pp_state_c& q, ship_command_c& u );
  bool plan_for_predator( pp_state_c& q, ship_command_c& u );
*/
  // send a command to stop the ship
  void stop( void );

  bool my_state( const pp_state_c& q, ship_state_c& qi );
  bool adversary_state( const pp_state_c& q, ship_state_c& qi );
  
  // computes the feedback command based on error in the current state
  ship_command_c compute_feedback( ship_state_c& q, ship_command_c& u );

  // compute the desired state based on the current command and current state
  void compute_desired_state( const ship_state_c& q0, const ship_command_c& u, ship_state_c& q );

  bool has_captured( const std::vector<double>& pred_state, const std::vector<double>& prey_state );

public:
  // computes commands (forces) if the ship is prey
  static void prey_command( const std::vector<double>& pred_state, const std::vector<double>& prey_state, std::vector<double>& prey_u, ship_p pred, ship_p prey , const double& time );

  // normalizes the quaternion components of the state
  static void renormalize_state_quat(std::vector<double>& q);

  // compute the bounding box for the ship given a state
  aabb_c aabb( const std::vector<double>& q );

  // query the bounding box for the ship in the current state
  aabb_c aabb( void );

  // query whether a bounding box intersects another bounding box
  bool intersects_any_obstacle( const aabb_c& mybb, aabb_c& obstacle );

  // query whether the ship intersects the world bounding box
  bool intersects_world_bounds( const aabb_c& mybb );

  // compute the inverse dynamics for the ship 
  static void inv_dyn( const std::vector<double>& q, const std::vector<double>& qdot_des, std::vector<double>& u, const ship_p ship );

  static void ode( const std::vector<double>& q, const std::vector<double>& u, std::vector<double>& dq, const ship_p ship );

  static unsigned int best_control( const ship_p pred, const ship_p prey, const std::vector<double>& q_in, std::vector<double>& q_out, const std::vector<double>& u0, std::vector<double>& u );

  // compute any force(field) that the boundary contributes to repel collision
  static Ravelin::Vector3d boundary_force( ship_p ship, space_c* space, const Ravelin::Vector3d& pos, const Ravelin::Vector3d& vel );

  // computes a repulsive force for a given distance
  static double repulsive_force( ship_p ship, double dist );

};

//-----------------------------------------------------------------------------

#endif // _GAZEBO_SHIP_H_

